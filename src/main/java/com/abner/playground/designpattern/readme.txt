创建型模式(5种):
工厂方法模式 (Factory Method):定义一个用于创建对象的接口，让子类决定实例化哪一个类.
抽象工厂模式 (Abstract Factory):提供一个接口，用于创建相关或依赖对象的家族，而无需指定它们具体的类.
单例模式 (Singleton):保证一个类只有一个实例，并提供一个全局访问点.
建造者模式 (Builder):分步构建一个复杂的对象，允许用户使用不同的表示形式来构造相同类型的对象.
原型模式 (Prototype):通过复制一个原型对象来创建新的对象.

结构型模式(7种):
适配器模式 (Adapter):将一个类的接口转换成客户端希望的另一个接口。适配器模式使得原本不兼容的类可以一起工作.
桥接模式 (Bridge):将抽象部分和实现部分分离，使它们都可以独立地变化.
装饰模式 (Decorator):动态地给一个对象添加一些额外的职责。就增加功能而言，装饰模式比生成子类更为灵活.
组合模式 (Composite):将对象组合成树形结构来表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性.
外观模式 (Facade):提供一个统一的接口，用来访问子系统的一组接口。外观模式简化了客户端与子系统之间的交互.
享元模式 (Flyweight):运用共享技术有效地支持大量细粒度的对象.
代理模式 (Proxy):为其他对象提供一个代理，以控制对这个对象的访问

行为型模式(11种):
策略模式（Strategy Pattern）：定义一系列算法，将它们封装成独立的策略类，使得它们可以互相替换而不影响客户端。
观察者模式（Observer Pattern）：定义一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知和自动更新。
模板方法模式（Template Method Pattern）：定义一个算法的骨架，将一些步骤延迟到子类实现。这样可以确保算法的结构保持不变，但允许不同的子类提供具体实现。
命令模式（Command Pattern）：将请求封装成一个对象，从而使得请求的发送者和接收者解耦。这允许我们根据需要参数化对象，将请求排队或记录日志，并支持撤销操作。
迭代器模式（Iterator Pattern）：提供一种方法来访问聚合对象中的各个元素，而不需要暴露其内部表示。
责任链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，从而允许多个对象处理请求。请求在对象链中沿着链传递，直到有一个对象处理它。
中介者模式（Mediator Pattern）：定义一个中介对象来封装一组对象之间的交互。中介者使得各个对象之间不需要显式地相互引用，从而减少耦合。
备忘录模式（Memento Pattern）：允许在不破坏封装的前提下捕获一个对象的内部状态，并在需要时将其恢复。
状态模式（State Pattern）：允许对象在其内部状态发生改变时改变其行为。对象看起来好像修改了其类。
访问者模式（Visitor Pattern）：定义一种将操作从对象结构中分离出来的方式。通过在不改变对象的类的前提下，可以在不同的对象上执行不同的操作。
解释器模式（Interpreter Pattern）：定义一种语言的文法规则，并为该语言创建一个解释器，以解释处理用户的输入
